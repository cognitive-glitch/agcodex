//! Simple usage example demonstrating the semantic indexing system
//!\n//! This example shows how to:\n//! - Create a semantic indexer\n//! - Index Rust source files  \n//! - Perform semantic searches\n//! - Retrieve relevant code chunks\n\nuse crate::semantic_index::*;\nuse std::path::PathBuf;\nuse tempfile::tempdir;\nuse tokio::fs;\n\n/// Example usage of the semantic indexing system\npub async fn run_example() -> Result<()> {\n    println!(\"üöÄ Semantic Indexing System Example\");\n    \n    // Create configuration\n    let config = SemanticIndexConfig {\n        max_documents: 1000,\n        embedding_dimensions: 384, // Smaller for demo\n        max_chunk_size: 1024,\n        similarity_threshold: 0.6,\n        max_results: 10,\n        ..Default::default()\n    };\n    \n    // Initialize indexer\n    let indexer = SemanticIndexer::new(config)?;\n    \n    // Create temporary directory with sample Rust code\n    let temp_dir = tempdir().unwrap();\n    let sample_files = create_sample_files(temp_dir.path()).await?;\n    \n    println!(\"üìÅ Created {} sample files\", sample_files.len());\n    \n    // Index the sample files\n    println!(\"‚ö° Indexing files...\");\n    let start = std::time::Instant::now();\n    \n    for file_path in &sample_files {\n        match indexer.index_file(file_path).await {\n            Ok(doc_id) => println!(\"  ‚úÖ Indexed: {} -> {}\", file_path.display(), doc_id),\n            Err(e) => println!(\"  ‚ùå Failed to index {}: {}\", file_path.display(), e),\n        }\n    }\n    \n    let indexing_time = start.elapsed();\n    println!(\"‚è±Ô∏è  Indexing completed in {:?}\", indexing_time);\n    \n    // Show indexing metrics\n    let metrics = indexer.get_metrics();\n    println!(\"üìä Indexing Metrics:\");\n    println!(\"  Documents: {}\", metrics.documents_indexed);\n    println!(\"  Chunks: {}\", metrics.chunks_created);\n    println!(\"  Embeddings: {}\", metrics.embeddings_generated);\n    println!(\"  Avg time/doc: {:.2}ms\", metrics.avg_indexing_time_ms);\n    \n    // Perform semantic searches\n    println!(\"\\nüîç Performing semantic searches...\");\n    \n    let search_queries = vec![\n        \"user authentication\",\n        \"error handling\", \n        \"data validation\",\n        \"async function\",\n        \"struct definition\",\n    ];\n    \n    for query_text in search_queries {\n        let query = SearchQuery::new(query_text)\n            .with_limit(3)\n            .with_threshold(0.5)\n            .with_scores();\n        \n        let search_start = std::time::Instant::now();\n        let results = indexer.search(query).await?;\n        let search_time = search_start.elapsed();\n        \n        println!(\"\\nüéØ Query: '{}'\", query_text);\n        println!(\"   Found {} results in {:?}\", results.len(), search_time);\n        \n        for (i, result) in results.iter().enumerate() {\n            println!(\"   {}. Score: {:.3} | File: {}\", \n                i + 1, \n                result.similarity_score,\n                result.file_path.as_deref().unwrap_or(\"<unknown>\")\n            );\n            \n            // Show snippet of content\n            let snippet = if result.content.len() > 100 {\n                format!(\"{}...\", &result.content[..100])\n            } else {\n                result.content.clone()\n            };\n            println!(\"      {}\", snippet.replace('\\n', \" \"));\n        }\n    }\n    \n    // Demonstrate document management\n    println!(\"\\nüìã Document Management:\");\n    let all_docs = indexer.list_documents(None);\n    println!(\"  Total documents: {}\", all_docs.len());\n    \n    let rust_docs = indexer.list_documents(Some(crate::ast_compactor::Language::Rust));\n    println!(\"  Rust documents: {}\", rust_docs.len());\n    \n    // Show final performance summary\n    println!(\"\\nüèÅ Performance Summary:\");\n    println!(\"  Indexing: {:.2}ms/document\", metrics.avg_indexing_time_ms);\n    println!(\"  Retrieval: {:.2}ms average\", metrics.avg_retrieval_time_ms);\n    println!(\"  Efficiency: {:.1}%\", metrics.efficiency_score() * 100.0);\n    \n    println!(\"\\n‚ú® Example completed successfully!\");\n    Ok(())\n}\n\n/// Create sample Rust files for demonstration\nasync fn create_sample_files(base_dir: &std::path::Path) -> Result<Vec<PathBuf>> {\n    let mut files = Vec::new();\n    \n    // User authentication module\n    let auth_file = base_dir.join(\"auth.rs\");\n    let auth_content = r#\"\n//! User authentication and authorization module\n\nuse std::collections::HashMap;\nuse std::time::{Duration, SystemTime};\n\n#[derive(Debug, Clone)]\npub struct User {\n    pub id: u64,\n    pub username: String,\n    pub email: String,\n    pub is_active: bool,\n}\n\n#[derive(Debug)]\npub struct AuthService {\n    users: HashMap<u64, User>,\n    sessions: HashMap<String, (u64, SystemTime)>,\n}\n\nimpl AuthService {\n    pub fn new() -> Self {\n        Self {\n            users: HashMap::new(),\n            sessions: HashMap::new(),\n        }\n    }\n    \n    /// Register a new user with validation\n    pub async fn register_user(\n        &mut self, \n        username: String, \n        email: String\n    ) -> Result<User, AuthError> {\n        // Validate input\n        if username.is_empty() {\n            return Err(AuthError::InvalidUsername);\n        }\n        \n        if !email.contains('@') {\n            return Err(AuthError::InvalidEmail);\n        }\n        \n        let user_id = self.users.len() as u64 + 1;\n        let user = User {\n            id: user_id,\n            username,\n            email,\n            is_active: true,\n        };\n        \n        self.users.insert(user_id, user.clone());\n        Ok(user)\n    }\n    \n    /// Authenticate user and create session\n    pub async fn authenticate(\n        &mut self, \n        username: &str, \n        password: &str\n    ) -> Result<String, AuthError> {\n        // Find user by username\n        let user = self.users.values()\n            .find(|u| u.username == username && u.is_active)\n            .ok_or(AuthError::UserNotFound)?;\n        \n        // In a real system, verify password hash\n        if password.len() < 8 {\n            return Err(AuthError::InvalidPassword);\n        }\n        \n        // Create session token\n        let session_token = format!(\"session_{}_{}_{}\", \n            user.id, \n            SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap().as_secs(),\n            rand::random::<u32>()\n        );\n        \n        self.sessions.insert(\n            session_token.clone(), \n            (user.id, SystemTime::now())\n        );\n        \n        Ok(session_token)\n    }\n    \n    /// Validate session and return user\n    pub fn validate_session(&self, token: &str) -> Result<&User, AuthError> {\n        let (user_id, created_at) = self.sessions.get(token)\n            .ok_or(AuthError::InvalidSession)?;\n        \n        // Check session expiry (1 hour)\n        if created_at.elapsed().unwrap() > Duration::from_secs(3600) {\n            return Err(AuthError::SessionExpired);\n        }\n        \n        self.users.get(user_id)\n            .ok_or(AuthError::UserNotFound)\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum AuthError {\n    #[error(\"Invalid username\")]\n    InvalidUsername,\n    \n    #[error(\"Invalid email address\")]\n    InvalidEmail,\n    \n    #[error(\"Invalid password\")]\n    InvalidPassword,\n    \n    #[error(\"User not found\")]\n    UserNotFound,\n    \n    #[error(\"Invalid session\")]\n    InvalidSession,\n    \n    #[error(\"Session expired\")]\n    SessionExpired,\n}\n\"#;\n    fs::write(&auth_file, auth_content).await.unwrap();\n    files.push(auth_file);\n    \n    // Data validation module\n    let validation_file = base_dir.join(\"validation.rs\");\n    let validation_content = r#\"\n//! Data validation utilities and error handling\n\nuse std::collections::HashMap;\nuse regex::Regex;\n\n/// Validation result with detailed error information\n#[derive(Debug, Clone)]\npub struct ValidationResult {\n    pub is_valid: bool,\n    pub errors: Vec<ValidationError>,\n    pub warnings: Vec<String>,\n}\n\nimpl ValidationResult {\n    pub fn new() -> Self {\n        Self {\n            is_valid: true,\n            errors: Vec::new(),\n            warnings: Vec::new(),\n        }\n    }\n    \n    pub fn add_error(&mut self, field: &str, message: String) {\n        self.is_valid = false;\n        self.errors.push(ValidationError {\n            field: field.to_string(),\n            message,\n        });\n    }\n    \n    pub fn add_warning(&mut self, warning: String) {\n        self.warnings.push(warning);\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct ValidationError {\n    pub field: String,\n    pub message: String,\n}\n\n/// Email validation with comprehensive checks\npub fn validate_email(email: &str) -> ValidationResult {\n    let mut result = ValidationResult::new();\n    \n    if email.is_empty() {\n        result.add_error(\"email\", \"Email cannot be empty\".to_string());\n        return result;\n    }\n    \n    // Basic format check\n    if !email.contains('@') {\n        result.add_error(\"email\", \"Email must contain @ symbol\".to_string());\n    }\n    \n    // More sophisticated regex validation\n    let email_regex = Regex::new(r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\").unwrap();\n    if !email_regex.is_match(email) {\n        result.add_error(\"email\", \"Invalid email format\".to_string());\n    }\n    \n    // Length validation\n    if email.len() > 255 {\n        result.add_error(\"email\", \"Email too long (max 255 characters)\".to_string());\n    }\n    \n    // Common domain validation\n    let parts: Vec<&str> = email.split('@').collect();\n    if parts.len() == 2 {\n        let domain = parts[1];\n        if domain.len() < 3 {\n            result.add_warning(\"Domain seems too short\".to_string());\n        }\n    }\n    \n    result\n}\n\n/// Password strength validation\npub fn validate_password(password: &str) -> ValidationResult {\n    let mut result = ValidationResult::new();\n    \n    if password.len() < 8 {\n        result.add_error(\"password\", \"Password must be at least 8 characters\".to_string());\n    }\n    \n    if password.len() > 128 {\n        result.add_error(\"password\", \"Password too long (max 128 characters)\".to_string());\n    }\n    \n    // Character type requirements\n    let has_lowercase = password.chars().any(|c| c.is_lowercase());\n    let has_uppercase = password.chars().any(|c| c.is_uppercase());\n    let has_digit = password.chars().any(|c| c.is_numeric());\n    let has_special = password.chars().any(|c| \"!@#$%^&*()_+-=[]{}|;:,.<>?\".contains(c));\n    \n    let strength_score = [has_lowercase, has_uppercase, has_digit, has_special]\n        .iter()\n        .filter(|&&x| x)\n        .count();\n    \n    match strength_score {\n        0..=1 => result.add_error(\"password\", \"Password too weak\".to_string()),\n        2 => result.add_warning(\"Consider adding more character types\".to_string()),\n        3 => result.add_warning(\"Good password strength\".to_string()),\n        4 => result.add_warning(\"Excellent password strength\".to_string()),\n        _ => unreachable!(),\n    }\n    \n    result\n}\n\n/// Generic field validator\npub fn validate_required_field(field_name: &str, value: &str) -> ValidationResult {\n    let mut result = ValidationResult::new();\n    \n    if value.trim().is_empty() {\n        result.add_error(field_name, format!(\"{} is required\", field_name));\n    }\n    \n    result\n}\n\n/// Batch validation for multiple fields\npub fn validate_fields(fields: HashMap<&str, &str>) -> ValidationResult {\n    let mut result = ValidationResult::new();\n    \n    for (field_name, value) in fields {\n        let field_result = validate_required_field(field_name, value);\n        if !field_result.is_valid {\n            result.is_valid = false;\n            result.errors.extend(field_result.errors);\n        }\n        result.warnings.extend(field_result.warnings);\n    }\n    \n    result\n}\n\"#;\n    fs::write(&validation_file, validation_content).await.unwrap();\n    files.push(validation_file);\n    \n    // Async utilities module\n    let async_file = base_dir.join(\"async_utils.rs\");\n    let async_content = r#\"\n//! Async utilities and helper functions\n\nuse std::future::Future;\nuse std::time::{Duration, Instant};\nuse tokio::time::{sleep, timeout};\n\n/// Retry an async operation with exponential backoff\npub async fn retry_with_backoff<F, Fut, T, E>(\n    mut operation: F,\n    max_attempts: usize,\n    initial_delay: Duration,\n) -> Result<T, E>\nwhere\n    F: FnMut() -> Fut,\n    Fut: Future<Output = Result<T, E>>,\n{\n    let mut delay = initial_delay;\n    \n    for attempt in 1..=max_attempts {\n        match operation().await {\n            Ok(result) => return Ok(result),\n            Err(e) if attempt == max_attempts => return Err(e),\n            Err(_) => {\n                println!(\"Attempt {} failed, retrying in {:?}\", attempt, delay);\n                sleep(delay).await;\n                delay *= 2; // Exponential backoff\n            }\n        }\n    }\n    \n    unreachable!()\n}\n\n/// Execute operation with timeout\npub async fn with_timeout<F, T>(\n    operation: F,\n    timeout_duration: Duration,\n) -> Result<T, TimeoutError>\nwhere\n    F: Future<Output = T>,\n{\n    match timeout(timeout_duration, operation).await {\n        Ok(result) => Ok(result),\n        Err(_) => Err(TimeoutError::TimedOut(timeout_duration)),\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum TimeoutError {\n    #[error(\"Operation timed out after {:?}\", .0)]\n    TimedOut(Duration),\n}\n\n/// Measure execution time of an async operation\npub async fn measure_time<F, T>(operation: F) -> (T, Duration)\nwhere\n    F: Future<Output = T>,\n{\n    let start = Instant::now();\n    let result = operation.await;\n    let elapsed = start.elapsed();\n    (result, elapsed)\n}\n\n/// Concurrent execution with results collection\npub async fn execute_concurrently<F, Fut, T>(\n    operations: Vec<F>,\n) -> Vec<T>\nwhere\n    F: FnOnce() -> Fut,\n    Fut: Future<Output = T> + Send,\n    T: Send,\n{\n    let futures = operations.into_iter().map(|op| op()).collect::<Vec<_>>();\n    futures::future::join_all(futures).await\n}\n\n/// Rate limiter for async operations\npub struct RateLimiter {\n    max_requests: usize,\n    window: Duration,\n    requests: std::sync::Arc<std::sync::Mutex<Vec<Instant>>>,\n}\n\nimpl RateLimiter {\n    pub fn new(max_requests: usize, window: Duration) -> Self {\n        Self {\n            max_requests,\n            window,\n            requests: std::sync::Arc::new(std::sync::Mutex::new(Vec::new())),\n        }\n    }\n    \n    pub async fn acquire(&self) -> Result<(), RateLimitError> {\n        let now = Instant::now();\n        \n        {\n            let mut requests = self.requests.lock().unwrap();\n            \n            // Remove old requests outside the window\n            requests.retain(|&time| now.duration_since(time) < self.window);\n            \n            // Check if we can make a new request\n            if requests.len() >= self.max_requests {\n                return Err(RateLimitError::RateLimitExceeded);\n            }\n            \n            requests.push(now);\n        }\n        \n        Ok(())\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum RateLimitError {\n    #[error(\"Rate limit exceeded\")]\n    RateLimitExceeded,\n}\n\"#;\n    fs::write(&async_file, async_content).await.unwrap();\n    files.push(async_file);\n    \n    Ok(files)\n}\n\n// Mock rand function for compilation\nmod rand {\n    pub fn random<T>() -> T \n    where \n        T: From<u32> \n    {\n        // Simple deterministic \"random\" for demo\n        T::from(42u32)\n    }\n}\n\n// Mock regex module for compilation\nmod regex {\n    pub struct Regex {\n        pattern: String,\n    }\n    \n    impl Regex {\n        pub fn new(pattern: &str) -> Result<Self, &'static str> {\n            Ok(Self {\n                pattern: pattern.to_string(),\n            })\n        }\n        \n        pub fn is_match(&self, text: &str) -> bool {\n            // Very simplified regex matching\n            text.contains('@') && text.contains('.')\n        }\n    }\n}\n\n// Mock futures module for compilation\nmod futures {\n    pub mod future {\n        use std::future::Future;\n        \n        pub async fn join_all<I>(iter: I) -> Vec<I::Item::Output>\n        where\n            I: IntoIterator,\n            I::Item: Future,\n        {\n            let mut results = Vec::new();\n            for future in iter {\n                results.push(future.await);\n            }\n            results\n        }\n    }\n}\n